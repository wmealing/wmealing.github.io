<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-10-05 Sun 18:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why eBPF for users is disabled in some distributions</title>
<meta name="generator" content="Org Mode" />
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="index.css">
<meta name="author" content="Wade Mealing" />
<meta http-equiv="Content-Security-Policy" content="style-src-elem 'self' https://wmealing.github.io;">
<meta name="description" content="Wade Mealings documentation" />
<meta http-equiv="Content-Security-Policy"  content="script-src 'self' ajax.googleapis.com;"" />
<meta http-equiv="Content-Security-Policy" content="style-src-elem; img-src https://*; child-src 'none';" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Why eBPF for users is disabled in some distributions</h1>
<div id="outline-container-org363979b" class="outline-2">
<h2 id="org363979b">Table of Contents</h2>
<div class="outline-text-2" id="text-org363979b">
<ul class="org-ul">
<li>Why eBPF filter operations are privileged in some distributions?</li>
<li>Why is this effectively limited to root (CAP_SYS_ADMIN) only?</li>
<li>How can I give a user access to use eBPF?</li>
<li>Conclusion</li>
</ul>
</div>
</div>
<div id="outline-container-org447b573" class="outline-2">
<h2 id="org447b573">Why eBPF filter operations are privileged in some distributions?</h2>
<div class="outline-text-2" id="text-org447b573">
<p>
eBPF is a mechanism in which local users can tell the Linux kernel to attach pseudocode to tracepoints, kprobes, and perf events in the kernel. This pseudocode is later translated into native instructions and executed. Because of this it is heavily used in performance tuning and benchmarking. As this instrumentation can be carried out without recompiling the kernel, eBPF is very attractive for systems where this could be prohibitive either due to cost, downtime, or complexity.
</p>

<p>
Using eBPF requires calling a syscall, bpf(2). This syscall is used for all eBPF operations like loading programs attaching them to specific events, creating eBPF maps, and access the map contents from tools. At this time, users with CAP_SYS_ADMIN capability in the initial namespace can use the bpf(2) syscall, which is effectively root level privileges.
</p>

<p>
To function correctly, the attached pseudocode requires access to privileged data from within the kernel. The eBPF developers have created an in-kernel verification system with in-depth checks before execution to ensure that potentially malicious code is not permitted.
</p>

<p>
It provides such checks as:
</p>

<ul class="org-ul">
<li>infinite loop prevention,</li>
<li>out of range data access,</li>
<li>invalid register states,</li>
<li>kernel address leakage protection, and</li>
<li>limiting internal function calls.</li>
</ul>
</div>
</div>
<div id="outline-container-org2c45f79" class="outline-2">
<h2 id="org2c45f79">Why is this effectively limited to root (CAP_SYS_ADMIN) only?</h2>
<div class="outline-text-2" id="text-org2c45f79">
<p>
The decision to limit this syscall to a user with CAP_SYS_ADMIN in the initial namespace was intended to reduce the attack surface available to potential intruders.
</p>

<p>
The more common use case of eBPF is to diagnose performance or system bottlenecks that the system is currently facing. As such it is mainly used in deep system-level debugging and performance tuning scenarios which a non-admin user on a production system is not supposed to do.
</p>

<p>
Kernel exploits are not a new problem; eBPF creates a new attack vector that contains additional attack vectors that were not previously accessible. By limiting the ability to run eBPF syscall to CAP_SYS_ADMIN (or root) only effectively disallows unprivileged (or regular) users of the system the ability to attack the kernel using this method. This also limits the attack surface of the subsystem. A local user with root access is expected to be able to perform actions that have equivalent or worse impacts.
</p>

<p>
Since pseudocode translation and verification is a complex process, error handling and preventing malicious behavior is very difficult. New code injected into the kernel at runtime makes a very useful target for attackers. Even with these prevention mechanisms in place there have been a number of flaws that have been found in the eBPF code, especially the verifier itself. Red Hat has limited eBPF access to a privileged operation and by doing so ensures that fewer additional rights are granted if eBPF is successfully attacked.
</p>
</div>
</div>
<div id="outline-container-org3e57e0e" class="outline-2">
<h2 id="org3e57e0e">How can I give a user access to use eBPF?</h2>
<div class="outline-text-2" id="text-org3e57e0e">
<p>
One possible workaround is to use setcap(8) to set the CAP_SYS_ADMIN flag on a trusted binary with minimal attack surface that would call the relevant bpf(2) syscall. For more information on the capabilities feature of the kernel check out capabilities(7).
</p>

<p>
The other alternative is to allow the user to execute the specific binary with the "sudo" command (see sudo(8) and sudoers(8)).
</p>

<p>
Red Hat Enterprise Linux does not have /proc/sys/kernel/unprivileged_bpf_disabled available to enable access to unprivileged users, and it is disabled by default. So, if you need it, you're out of luck.
</p>
</div>
</div>
<div id="outline-container-orge0d811f" class="outline-2">
<h2 id="orge0d811f">Conclusion</h2>
<div class="outline-text-2" id="text-orge0d811f">
<p>
Some Linux distributions, in the future, may ship with the ability to allow users to insert eBPF rules. At this time RHEL and CENTOS has attempted to reduce the risk of eBPF exploitation by limiting access to root and CAP_SYS_ADMIN enabled processes. This trade-off reduces the attack vector on the system at the cost of limiting which users can take advantage of eBPF functionality.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-10-05 Sun 18:02</p>
</div>
</body>
</html>
