<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-10-07 Tue 16:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lfe Flavored Erlang Gen Server</title>
<meta name="generator" content="Org Mode" />
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta http-equiv="Content-Security-Policy" content="style-src-elem 'self' https://wmealing.github.io;">
<link rel="stylesheet" href="index.css">
<meta name="author" content="Wade Mealing" />
<meta name="description" content="Lisp Flavored Erlang - A gen server story" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Lfe Flavored Erlang Gen Server</h1>
<p>
Recently Iâ€™ve spent some time learning Lfe Flavored Erlang. So far I'm really enjoying it.  I've done
quite a bit of erlang in my past and this is how I think i could branch out into something a little more
modern.  I did consider Elixir, but it feels too alien to me.
</p>

<p>
This particular entry talks about my method of using TDD to develop a simple application using a concept
from erlang named <a href="https://www.erlang.org/doc/man/gen_server.html">gen_server</a>.
</p>

<p>
Think of it like a 'program skeleton'.  There are other "x-server" relatives in erlang, but gen_server is the
mac daddy of them all.
</p>
<div id="outline-container-org544289c" class="outline-3">
<h3 id="org544289c">What is a gen server ?</h3>
<div class="outline-text-3" id="text-org544289c">
<p>
A "Generic Server" is a long running process within the BEAM virtual machine that expects the developer to create callbacks to fill in specific behavior.
</p>

<p>
Erlang heavily uses processes, they are super cheap so why not.  Using the gen_server behavior creates a predictable implementation
that other erlang, elixir or lfe programmers would know and expect how to use.  It also fits nicely into the ability for the BEAM vm to supervise gen_servers and
restart them when they crash.  This allows us to bring the erlang "Let it crash" mentality to a lfe, and I think that is pretty neat.
</p>

<p>
As the LFE lies heavily on the erlang and BEAM, I'll be referncing the erlang docs as I go.
</p>

<p>
Lets start off our test driven adventure by making a new project, lets call it the pseudobank.
</p>

<p>
This assumes you have rebar3 installed and ready to rock.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ rebar3 new lfe-app <span style="font-weight: bold; font-style: italic;">name</span>=<span style="font-style: italic;">"pseudobank"</span>
===&gt; Writing pseudobank/README.md
===&gt; Writing pseudobank/LICENSE
===&gt; Writing pseudobank/rebar.config
===&gt; Writing pseudobank/.gitignore
===&gt; Writing pseudobank/src/pseudobank.lfe
===&gt; Writing pseudobank/src/pseudobank-app.lfe
===&gt; Writing pseudobank/src/pseudobank-sup.lfe
===&gt; Writing pseudobank/src/pseudobank.app.src
</pre>
</div>

<p>
The rebar.config file has a problem, it wont build because software is complex, you should change
your deps to use lfe 2.0.1 and plugins to use rebar3_lfe 0.4.0.  This may be fixed by the time
that you read this, you can find the bugreport <a href="https://github.com/lfe/rebar3_lfe/issues/72">here</a>.
</p>

<pre class="example" id="org19e462a">
{deps, [
    {lfe, "2.0.1"},
    {ltest, "0.13.0"}
]}.

{plugins, [
    {rebar3_lfe, "0.4.0"}
]}.

</pre>

<p>
This created a pretty standard "app" for lfe, with a default structure. The
keen eye may notice the "sup" (standing for supervisor) and we'll get to that later.
</p>

<p>
One thing it doesn't have is any testing!  The "lfe-app" template is wired up for tests
but doesn't have the directory or templates to work from so, lets make that now.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ mkdir pseudobank/test/
</pre>
</div>

<p>
Inside this directory lets start our test driven development by making a file containing
a test that we know will fail.
</p>

<p>
Using your editor create a file <code>pseudobank/tests/pseudobank-tests.lfe</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defmodule pseudobank-tests
   (behaviour ltest-unit))

(include-lib <span style="font-style: italic;">"ltest/include/ltest-macros.lfe"</span>)

<span style="font-weight: bold; font-style: italic;">;;; </span><span style="font-weight: bold; font-style: italic;">-----------
</span><span style="font-weight: bold; font-style: italic;">;;; </span><span style="font-weight: bold; font-style: italic;">library API
</span><span style="font-weight: bold; font-style: italic;">;;; </span><span style="font-weight: bold; font-style: italic;">-----------
</span>(deftest account-server-starts
    (<span style="font-weight: bold;">let</span> (((tuple 'ok pid) (account:start)))
      (is (is_pid pid))))
</pre>
</div>

<p>
This test "starts" the gen_server (we're going to make one called account).  Like normal 'programs'
that run on the computer, the gen_server has a 'process' id that is returned when the start function
is calle.d  We're pattern matching the return value and checking that the return value is a pid
with the "is_pid".
</p>

<p>
The "is" function above is part of the ltest macros.n
</p>

<p>
We can now run the test, its going to fail because we haven't written the 'account' gen server
but lets start.
</p>

<p>
From the shell within the 'pseudobank' directory:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ rebar3 lfe ltest
    ===&gt; Verifying dependencies...
    ===&gt; Compiling pseudobank
    ================================ <span style="font-weight: bold; font-style: italic;">ltest</span> =================================

    ------------------------------ Unit Tests ------------------------------

    module: pseudobank-tests
      module <span style="font-style: italic;">'pseudobank-tests'</span> ....................................... [fail]

          Assertion failure:
          undef

      <span style="font-weight: bold;">time</span>: 14ms

    summary:
      Tests: 1  Passed: 0  Skipped: 0  Failed: 1 Erred: 0
      Total time: 14ms


    ========================================================================
</pre>
</div>

<p>
Your version will likely be much more colorful, I'm sure you can use your imagination. More specific
tests can be run, but you can check out how to do that with the command "rebar3 help lfe ltest"
</p>

<p>
Lets fix that.. we'll make the account gen server first.
</p>

<p>
Lets make one in <code>src/account.lfe</code>
</p>


<div class="org-src-container">
<pre class="src src-lisp">(defmodule account
                (behaviour gen_server)
                (export all))

<span style="font-weight: bold; font-style: italic;">;;; </span><span style="font-weight: bold; font-style: italic;">helper functions
</span>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">server-name</span> () (MODULE))
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">register-name</span> () `#(local ,(server-name)))
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">callback-module</span> () (MODULE))
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">initial-state</span> () 0)
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">genserver-opts</span> () '())

<span style="font-weight: bold; font-style: italic;">;;; </span><span style="font-weight: bold; font-style: italic;">gen_server implementation
</span>
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">start</span> ()
  (gen_server:start (register-name)
                    (callback-module)
                    (initial-state)
                    (genserver-opts)))
</pre>
</div>

<p>
Now we have the start function, this looks like quite a lot of noise but this is the skeleton
startup code used for any gen_server.
</p>

<p>
Now when you run the test, we can see the test fails.
</p>

<pre class="example" id="org76263e1">
module: pseudobank-tests
  module 'pseudobank-tests' ....................................... [fail]

      Assertion failure:
=CRASH REPORT==== 22-Oct-2022::02:48:36.950759 ===
  crasher:
    initial call: account:init/1
    pid: &lt;0.400.0&gt;
    registered_name: []
    exception error: undefined function account:init/1
      in function  gen_server:init_it/2 (gen_server.erl, line 423)
      in call from gen_server:init_it/6 (gen_server.erl, line 390)

      &lt;snip&gt;
</pre>

<p>
We have a backtrace, which shows the path of the callback from gen_server initialization. Its crashing
in "account:init" which is not surprisingly really, we are missing the account:init function,
</p>

<p>
This is one of thoe callbacks that gen_server expects. Fortunately the gen_server page outlines the callbacks
expected, however not all are required.
</p>

<p>
Lets add the init callback by appending the following to the <code>account.lfe</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">init</span> (initial-state)
  `#(ok ,initial-state))
</pre>
</div>

<p>
This function initiates the initial internal state that the gen_server keeps with itself until it dies or restarts.
</p>

<p>
This function can return #(ok anything) as long as its 'ok' the gen_server doesn't care what we have done, it could hold state for any reason.
If it returns #(error anything), thats a good sign that the initialization procedure didnt work correctly.
</p>

<p>
Now when we run the test again:
</p>

<pre class="example" id="org206d3d4">
module: pseudobank-tests
  module 'pseudobank-tests' ......................................... [ok]
</pre>

<p>
We can see the test passes.
</p>
</div>
</div>
<div id="outline-container-orge4ff1d2" class="outline-3">
<h3 id="orge4ff1d2">Getting the balance</h3>
<div class="outline-text-3" id="text-orge4ff1d2">
<p>
Now, lets talk about money.  Lets check to see if it starts with zero balance.
</p>

<p>
Start by writing the test, I add a new test in the <code>pseudobank-test.lfe</code> file.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(deftest account-server-starts-with-zero-balance
  (account:start)
  (is-equal 0.00 (account:get-balance)))
</pre>
</div>

<p>
When running the test, you'll see it returns 'undef' again.
</p>

<div class="org-src-container">
<pre class="src src-sh">account_server_starts_with_zero_balance ......................... [fail]

Assertion failure:
  undef
</pre>
</div>

<p>
This is of course, because get-balance function doesn't exist.  The simple
solution is to start, making a get-balance function in the file.  Lets do that.
</p>

<p>
I usually try to do the simplest possible thing to get a test passing.  So i'm going
to make a function that returns a hard-coded 0.  This wont be using all the 'gen_server'
goodies, but its something to work from.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">get-balance</span> ()
  0)
</pre>
</div>

<p>
Lets use the gen_servers "state" to store the balance, so as long as the "account" process
is running we can access the current account value.
</p>

<p>
We'll modfy 'init' to return a map.  In LFE the map is represented as #M( key value &#x2026; &#x2026;),
Below is the modified init, to use a monetary value for the amount in the account.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">init</span> (initial-state)
  `#(ok ,#M(balance 0.00)))
</pre>
</div>

<p>
Now we modify the get-balance/0 function to call the <code>gen_server:call/3</code> function.
The first argument is the process ID, the second parameter is passed to the <code>handle_call/3</code> callback that
gen_server expects the user to provide.
</p>

<p>
The gen_server:call function is synchronous, so your application will wait around for however long the work done takes.
</p>

<p>
Lets fix up get-balance as we talked about earlier:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">get-balance</span> ()
  (gen_server:call (server-name) 'get-balance))
</pre>
</div>

<p>
This uses the (server-name) helper function to look up the 'gen_server' by its name.
</p>

<p>
The gen_server will relay the call function back to handle_call function which we will implement now.
</p>

<p>
Lets run the test to check our expectations.
</p>

<p>
We can see the <code>CRASH REPORT</code> in the <code>undefined function account:handle_call/3</code>
when the code is looking for handle_call, which we have not created.
</p>

<pre class="example" id="org92c9983">
=CRASH REPORT==== 22-Oct-2022::03:37:19.059020 ===
crasher:
  initial call: account:init/1
  pid: &lt;0.536.0&gt;
  registered_name: account
  exception error: undefined function account:handle_call/3
    in function  gen_server:try_handle_call/4 (gen_server.erl, line 721)
    in call from gen_server:handle_msg/6 (gen_server.erl, line 750)
</pre>

<p>
Lets make that now, the simplest possible implementation
</p>

<div class="org-src-container">
<pre class="src src-lisp">(handle_call
 ((_message _caller state)
  `#(reply 0.00 ,state)))
</pre>
</div>


<p>
For those who dont write much lisp or erlang, you can specify a pattern matching operation
on the functions heads, its a pretty neat feature but will be surprising if you dont remember/know about it.
The LFE tutorial talks about it <a href="https://lfe.gitbooks.io/tutorial/content/sequential/conds.html#function-heads-as-conditionals">here</a>.
</p>


<p>
Words that start with an underscore, means 'we dont care about it' so in this case we're accepting
-every- message and not matching on the first term.  This wont be the case later but it works for now.
</p>

<p>
Now when we run the tests, we can see what it is returning.
</p>

<pre class="example" id="org0f41ec2">
account_server_starts_with_zero_balance ......................... [fail]

    Assertion failure:
    #(assertEqual
             (#(module pseudobank-tests)
              #(line 15)
              #(expression "(account:get-balance)")
              #(expected 0)
              #(value 'message-goes-here)))
</pre>

<p>
We can see its returning the "message-goes-here" from the callback instead of the zero.  Lets return
the current balance (0.00) now.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">handle_call</span>
((_message  _caller state)
 `#(reply ,(map-get state 'balance),state)))
</pre>
</div>

<p>
At this point it still ignores the message and the caller, but it returns the balance
that was set created/set during the init function.
</p>

<p>
The change is to the second return arguement,  we use <code>(map-get &lt;mapname&gt; &lt;key&gt; )</code> to get the value,
we know the key is an atom called 'balance so this would transform into after all values are evaluated.
</p>

<div class="org-src-container">
<pre class="src src-lisp">#(reply 0 #M(balance 0.00))
</pre>
</div>

<p>
Cool, so now we have a basic "get the current balance" <code>gen_server</code> working, lets add a new
test to deposit money into the account.
</p>
</div>
</div>
<div id="outline-container-org1e9daf9" class="outline-3">
<h3 id="org1e9daf9">Making a deposit.</h3>
<div class="outline-text-3" id="text-org1e9daf9">
<p>
Back in <code>pseudobank-test.lfe</code> to add a new failing test for depositing money.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(deftest account-server-deposit-works
  (account:start)
  (<span style="font-weight: bold;">let</span> ((starting-balance (account:get-balance))
        (deposit-amount 1.23))
    (account:deposit deposit-amount)
    (is-equal (+ starting-balance deposit-amount) (account:get-balance))))
</pre>
</div>

<p>
This test is a little more involved, it starts the account process (its probably already started by another test),
then sets two values, 'starting-balance' to the accounts current-balance and 'deposit-amount' is an arbitrary amount. value was chosen, just because it looks fun.
</p>

<p>
When we run this module tests, ltest cant find the account:deposit function, lets make it.
</p>

<p>
This is the 'helper' function which can be called, which in turn calls gen-server with the two parameters.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">deposit</span> (amount)
  (gen_server:call (server-name) ('deposit amount)))
</pre>
</div>

<p>
Like the <code>get-balance</code> function, it will also be sent to the <code>handle_call/3</code> callback function, however it
passes a tuple of the 'deposit atom and an amount instead of just an atom.
</p>

<p>
Lets fix up <code>handle_call/3</code> to match this new callback request.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">handle_call</span>
(('get-balance _caller state)
 `#(reply ,(map-get state 'balance) ,state))
(((tuple 'deposit amount) _caller state)
 `#(reply 'ok, ,(map-update state 'balance 1.23))))
</pre>
</div>

<p>
The changes are: <code>'get-balance</code> in the first match, as we have multiple entries into the handle_call
we now need to get more specific and have the <code>'get-balance</code> specifically handle only the calls from
the 'get-balance helper, otherwise it will match for when we try to do a deposit.
</p>

<p>
We added the 'second' match clause for handle_call when it the first parameter is (tuple 'deposit some-amount).
</p>

<p>
The return value from this match is the same format, we're not going to tell the caller the new balance, but
we need to update the state in the most naive method.  Lets check the test run output:
</p>

<pre class="example" id="orgda88ff8">
module: pseudobank-tests
  account_server_starts ............................................. [ok]
  account_server_starts_with_zero_balance ........................... [ok]
  account_server_deposit_works ...................................... [ok]
</pre>

<p>
The <code>handle_call/3</code> callback is only returning a hard coded value, and what is
required is to to find the current value, add the deposit value and update the proccesses
internal state with the newly computed value.
</p>

<p>
Back to the <code>account.lfe</code> file, to fix this oversight:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">handle_call</span>
  (('get-balance _caller state)
   `#(reply ,(map-get state 'balance) ,state))
  (((tuple 'deposit amount) _caller state)
   `#(reply 'ok
            ,(map-update state 'balance
                         (+ (map-get state 'balance) amount)))))
</pre>
</div>

<p>
The difference is now that it checks the previous value, adds the requested amount to the previous vale
and updates the process state by returning all this in the third element of the tuple from the function <code>handle_call</code>.
</p>

<p>
I'd say we had desposits nailed.
</p>
</div>
</div>
<div id="outline-container-org83b8e32" class="outline-3">
<h3 id="org83b8e32">Making a withdrawal</h3>
<div class="outline-text-3" id="text-org83b8e32">
<p>
The withdrawal is removing money from your bank account.  Like the bank accounts of old, there will need to be
logic to ensure that your account doesn't go into the negative (The bank wouldnt want any of their fictional
money to go to YOU!)  Lets start by writing a test to ensure we can take money from the account.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(deftest account-server-withdrawal-works
(account:start)
(<span style="font-weight: bold;">let</span> ((starting-balance (account:get-balance))
      (deposit-amount 10.00)
      (withdraw-amount 1.00))
  (account:deposit deposit-amount)
  (account:withdraw withdraw-amount)
  (is-equal (- deposit-amount withdraw-amount) (account:get-balance))))
</pre>
</div>

<p>
This is a little more complex, we deposit 10.00 and then take away 1.00.  This should
lead to having 9.00 in the account.  When we run this test , it once again returns 'undef'
because the withdraw function is not implemented.  Hop to it then.
</p>

<p>
Back in <code>account.lfe</code>, we'll make the helper function.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">withdraw</span> ( amount )
  (gen_server:call (server-name) (tuple 'withdraw amount)))
</pre>
</div>

<p>
The callback doesn't handle the (tuple 'withdraw amount), make it happen.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">handle_call</span>

  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">get balance functionality
</span>  (('get-balance _caller state)
   `#(reply ,(map-get state 'balance) ,state))

  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">deposit functionality
</span>  (((tuple 'deposit amount) _caller state)
   `#(reply 'ok
            ,(map-update state 'balance
                         (+ (map-get state 'balance) amount))))

  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">withdraw money functionality.
</span>  (((tuple 'withdraw amount) _caller state)
   `#(reply 'ok
            ,(map-update state 'balance
                         (- (map-get state 'balance) amount)))))
</pre>
</div>

<p>
The withdraw callback isnt feature complete, its pretty much a basic modification of 'deposit feature.
It doesn't do any validation of values.
</p>

<p>
And now the test..
</p>

<div class="org-src-container">
<pre class="src src-lisp">account_server_withdrawal_works ................................. [fail]

  Assertion failure:
  #(assertEqual
           (#(module pseudobank-tests)
            #(line 26)
            #(expression <span style="font-style: italic;">"(account:get-balance)"</span>)
            #(expected 9.0)
            #(value 10.23)))
</pre>
</div>

<p>
Ok, thats weird.  It looks like the value of 10.23 is 1.00 dollar less than the final state
from the last test.  We're going to have to implement some kind of shutdown mechanism which
we can run after the test finishes to reset the state.
</p>
</div>
</div>
<div id="outline-container-org6a9072f" class="outline-3">
<h3 id="org6a9072f">Withraw Interlude: gen_server shutdown.</h3>
<div class="outline-text-3" id="text-org6a9072f">
<p>
As the LFE gen-server piggy backs on the <code>erlang</code> implementation of gen_server the
<a href="https://www.erlang.org/doc/man/gen_server.html">stdlib reference manual</a> includes a method to shut down the server.
</p>

<p>
The manual goes into return values for <a href="https://www.erlang.org/doc/man/gen_server.html#Module:handle_call-3">handle_call/3</a> specifies that the gen_server
can be terminated if handle_call returns the right tuple.
</p>

<pre class="example" id="org9dbcffc">
{stop,Reason,NewState}
</pre>

<p>
Which would call the (module:terminate Reason NewState) function.
</p>

<p>
In our example we could just ignore the values sent to the terminate function, but
there may be cases where you could use it, like stuffing it into a database, logging
or firing the state up again after some modification.
</p>

<p>
Here is the helper function, which triggers handle_call with the argument <code>'stop</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">stop</span> ()
  (gen_server:call (server-name) 'stop))
</pre>
</div>

<p>
And now lets add this to handle_call, i'll only include the match part of handle_call, You can check the
<a href="http://github.com/wmealing/psuedobank/src/account.lfe">file in github</a> for the full function, here is the basics.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(('stop _caller state-data)
   `#(stop shutdown ok state-data))
</pre>
</div>

<p>
And the matching expected terminate function.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">terminate</span> ( _reason _newstate )
    'ok)
</pre>
</div>

<p>
Now that the shutdown function is implemented, add a test to see if starting, shutting down
and starting up again works.
</p>

<p>
Here is our test:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(deftest account-server-starts-and-stops
  (<span style="font-weight: bold;">let</span> ((stop-val (account:stop))
        (start-val-pid (tref (account:start) 2))
        (stop-again-val (account:stop)))
    (is-equal stop-val 'ok)
    (is-equal (is_pid start-val-pid) 'true)
    (is-equal stop-again-val 'ok)))
</pre>
</div>

<p>
Now lets run the test.
</p>

<div class="org-src-container">
<pre class="src src-sh">module: pseudobank-tests
  account_server_starts ............................................. [ok]
  account_server_starts_with_zero_balance ........................... [ok]
  account_server_deposit_works ...................................... [ok]
  account_server_withdrawal_works ................................... [ok]
  account_server_starts_and_stops ................................... [ok]
</pre>
</div>

<p>
Giddy up, now we have the server restarting, but back to the topic at hand getting
withdraw and its rules
</p>
</div>
</div>
<div id="outline-container-org59d0901" class="outline-3">
<h3 id="org59d0901">Withdraw resumed:</h3>
<div class="outline-text-3" id="text-org59d0901">
<p>
Lets get back to withdraw, to fix it.. the next thing we need to implement is ensure that
you cant withdraw can not put it the account balance into negative value. Here's the test.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(deftest account-server-withdraw-negative-test
  (account:start)
    (<span style="font-weight: bold;">let*</span> ((starting-balance (account:get-balance))
          (deposit-amount 1.00)
          (withdraw-amount 200.00))
      (account:deposit deposit-amount)
      (is (=:= (account:withdraw withdraw-amount) 'insufficient-funds))))
</pre>
</div>

<p>
This test will fail when we run the test because there has been no error condition
returning 'insufficient-funds when the withdraw amount exceeds available balance.
</p>

<p>
Fixing that now, we're modifying <code>handle_call</code> to include a conditional return based
on if the amount is greater than the balance.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">withdraw
</span>(((tuple 'withdraw amount) _caller state)

 <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">first step, check that amount is less than the current balance.
</span> (<span style="font-weight: bold;">if</span> (&gt; amount (map-get state 'balance))
   <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">true condition
</span>   `#(reply ,'insufficient-funds ,state)
   <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">false condition
</span>   `#(reply ,'ok ,(map-update state 'balance (- (map-get state 'balance) amount)))))
</pre>
</div>

<p>
All tests should now pass.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ rebar3 as test lfe ltest
===&gt; Verifying dependencies...
===&gt; Compiling pseudobank
================================ <span style="font-weight: bold; font-style: italic;">ltest</span> =================================

------------------------------ Unit Tests ------------------------------

module: pseudobank-tests
  account_server_starts ............................................. [ok]
  account_server_starts_with_zero_balance ........................... [ok]
  account_server_deposit_works ...................................... [ok]
  account_server_withdrawal_works ................................... [ok]
  account_server_starts_and_stops ................................... [ok]
  account_server_withdraw_negative_test ............................. [ok]
  <span style="font-weight: bold;">time</span>: 25ms

summary:
  Tests: 6  Passed: 6  Skipped: 0  Failed: 0 Erred: 0
  Total time: 43ms
</pre>
</div>

<p>
This isnt an exhaustive test suite, but its the basics of the gen_server and
test driven development for lfe.  I'll upload the project to github and put a
link right here soon.
</p>
</div>
</div>
<div id="outline-container-orge969feb" class="outline-2">
<h2 id="orge969feb">Resources:</h2>
<div class="outline-text-2" id="text-orge969feb">
<ul class="org-ul">
<li><a href="https://www.erlang.org/doc/man/gen_server.html#Module:handle_call-3">https://www.erlang.org/doc/man/gen_server.html#Module:handle_call-3</a></li>
<li><a href="https://www.erlang-factory.com/upload/presentations/523/EFSF2012-Implementinglanguages.pdf">https://www.erlang-factory.com/upload/presentations/523/EFSF2012-Implementinglanguages.pdf</a></li>
<li><a href="https://github.com/lfex/ltest">https://github.com/lfex/ltest</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
