<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-01-25 Sun 16:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Using erlangs remote shell during devel.</title>
<meta name="generator" content="Org Mode" />
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta http-equiv="Content-Security-Policy" content="style-src-elem 'self' https://wmealing.github.io;">
<link rel="stylesheet" href="index.css">
<meta name="author" content="Wade Mealing" />
<meta name="description" content="Using erlangs repl and remote shell during development" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Using erlangs remote shell during devel.</h1>
<div id="outline-container-orgc1f418a" class="outline-2">
<h2 id="orgc1f418a">Summary:</h2>
<div class="outline-text-2" id="text-orgc1f418a">
<p>
Have you ever worked on a project, you write enough code that you're looking at ways to reduce the time it takes
to turn your idea into working, tested code.  The ideas are many, but it feels like your wasted minutes add up so
very quickly into an hour and the solutions start to boil in the back of your mind.
</p>

<p>
Ok, so you're writing tests and the tests prove the code is correct and work, so you find a quick
way to run the 'eunit' tests in erlang itself, from a single chord.
</p>

<p>
Cool you think to yourself, thats quicker, but you remember the times you wrote lisp, and how quick the repl was,
that you could make changes to the live project and see its behavior change in real time.
</p>

<p>
A spark burns in the back of your mind, you remember how rapidly you could develop on the common-lisp repl..
erlang has a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">repl</a>, so why not see what we can do.
</p>

<p>
I wont be the first to talk about this, but I haven't seen anyone demonstrate a tight feedback loop from the editor
into the erlang repl.
</p>
</div>
</div>
<div id="outline-container-org67bc4b6" class="outline-2">
<h2 id="org67bc4b6">Introduction</h2>
<div class="outline-text-2" id="text-org67bc4b6">
<p>
Erlang is a distributed system out of the box and the <a href="https://www.erlang.org/doc/apps/stdlib/shell.html">erlang shell</a> itself allows for a system to connect to any of
the nodes in the <a href="https://www.erlang.org/doc/system/distributed.html">distributed erlang system</a>.  The distribution itself demonstrated here is the non encrypted nono tls/ssl
so probably not the best idea to do outside of development.
</p>

<p>
The <a href="https://www.erlang.org/doc/apps/ssl/ssl_distribution">ERTS documentation</a> even suggests:
</p>

<blockquote>
<p>
âš  Warning:
</p>

<p>
Starting a distributed node without also specifying -proto_dist inet_tls will expose the node to
attacks that may give the attacker complete access to the node and in extension the cluster.
</p>
</blockquote>

<p>
If you dont secure this and do something better in production,  something like my <a href="https://github.com/wmealing/Elixir-virus">virus</a> could end up using your code
to laterally across different systems.  
</p>

<p>
Firing up the emacs repl requires you to install erlang-mode and starting the erlang-shell with a few parameters.
</p>

<p>
You must setup emacs, this replaces the 'erlang-shell' with a remote erlang shell, that connects to the already running node.
</p>
</div>
</div>
<div id="outline-container-org8353f0a" class="outline-2">
<h2 id="org8353f0a">Specifics:</h2>
<div class="outline-text-2" id="text-org8353f0a">
<p>
The 'main' erlang program must be started before you can connect another "shell" to it.  Lisp people  may call this a 'networked repl', but in erlang parlance
it is called a 'remote shell'.  In this case both 'nodes' are on the same machine but there is nothing stopping you from doing this in
a more distributed environment.
</p>

<div class="org-src-container">
<pre class="src src-make">&lt;stuff cut here here&gt;

EXTRAS_EBIN = -pa ./_build/default/extras/examples/
export EXTRAS_EBIN

LIB_EBIN = -pa _build/default/lib/*/ebin
export LIB_EBIN

node1-noshell:
        erl -sname node1 -setcookie mysecretcookie -noshell  -noinput \
        $(LIB_EBIN) $(EXTRAS_EBIN) 

rebar3-shell
        rebar3 shell --sname node1 --setcookie mysecretcookie

node1-noshell-yourapp:
        erl -sname node1 -setcookie mysecretcookie -noshell  -noinput \
        $(LIB_EBIN) $(EXTRAS_EBIN) --eval "yourapp:start()"

</pre>
</div>

<p>
You'd start the 'main' program with the command:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ make node1-shell
</pre>
</div>

<p>
or
</p>

<div class="org-src-container">
<pre class="src src-sh">$ make rebar-shell
</pre>
</div>

<p>
Or if you're feeling lucky you can execute the command by line, the goal is to ensuret hat you have the nodename configured
to node1.
</p>

<p>
Modify your emacs, to evaluate this code,
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun remote-erlang-shell ()
  "Starts an inferior Erlang shell with a randomized -sname using a random string."
  (interactive)
  (let* (
         (chars "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
         (len 5)      ; Length of the random part (e.g., 5 characters)
         (random-part (with-temp-buffer
                        (dotimes (i len)
                          (insert (aref chars (random (length chars)))))
                        (buffer-string)))
         (random-name (concat "node-" random-part))
         (command (format "erl -sname %s -setcookie mysecretcookie -remsh node1" random-name)))
    (inferior-erlang command)))
</pre>
</div>

<p>
Each node in the 'cluster' must have a unique name, this lisp code creates a random name for the local connection and connects to the remote node.
</p>

<p>
Now when executing <b>m-x remote-erlang-shell</b> , within emacs it should try to connect to the 'remote node' (in this case whatever node1 is running).
</p>

<p>
If the runtime tells you it can't find node1, check to <a href="https://www.erlang.org/faq/problems">Section 9.8 - Why won't my distributed Erlang nodes communicate?</a>.
</p>

<p>
Now when you compile an erlang file, (C-c C-k or erlang-compile) it should compile (and be loadable) in the same
remote node.
</p>

<p>
If the code compiles to a location where the BEAM vm will find it, the next time the code runs through a function in the module, the
vm should pick up and use the new function.
</p>

<p>
This allows you to do do 'live' repl updates to the running application, see the demo here when i'm working on an early version of cellium.
</p>

<p>
<video  controls="controls"><source src="././images/LiveErlang.mp4" type="video/mp4"></video>
</p>

<p>
It is not strictly limited to 'compiling' code, you can also write erlang functions that you would run at the repl, and I've always wanted to say this, I leave it as an exercise to the reader.
</p>
</div>
</div>
<div id="outline-container-org55df9a6" class="outline-2">
<h2 id="org55df9a6">Conclusion</h2>
<div class="outline-text-2" id="text-org55df9a6">
<p>
This workflow is super convenienct; it fundamentally changes the nature of the interaction
with the system. By adopting the <b><b>remote shell workflow</b></b>, you are no longer treating your application as a
fragile, compiled artifact that must be stopped and restarted after every minor change. Instead, you're embracing
the true power of Erlang/OTP: <b><b>live, continuous development and maintenance.</b></b>
</p>

<p>
This is the very essence of "operational elegance" in Erlang. Not only can you 'let it crash', but you can debug
problems in the live system.
</p>

<p>
The ability to connect, inspect, and update code <b>in-situ</b> is a critical advantage for building <b>highly available, fault-tolerant systems*</b> that truly never have to go down. Stop the cycle of restarts and start
developing your Erlang application the way it was designed to be run: <a href="https://jackrusher.com/strange-loop-2022/"><b>alive</b></a>.
</p>
</div>
</div>
<div id="outline-container-orgc4356d8" class="outline-2">
<h2 id="orgc4356d8">Resources:</h2>
<div class="outline-text-2" id="text-orgc4356d8">
</div>
<div id="outline-container-org53dd870" class="outline-3">
<h3 id="org53dd870"><a href="https://www.erlang.org/doc/system/code_loading.html">Erlang/OTP Documentation (The Core)</a></h3>
<div class="outline-text-3" id="text-org53dd870">
<p>
<b><b>Code Loading Mechanism (Hot Code Swapping)</b></b>: A  deep-dive explanation of "Code Replacement" and the "Current" and "Old" module versions.
</p>

<p>
<a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html">Erlang/OTP Documentation: Compilation and Code Loading</a>
</p>

<p>
<b><b>The Erlang Command (`erl`)</b></b>: Reference for all the crucial flags used to start a distributed node, including `-sname`, `-setcookie`, and `-remsh`.
</p>
</div>
</div>
<div id="outline-container-org8bbb415" class="outline-3">
<h3 id="org8bbb415">Community Tutorials and Guides</h3>
<div class="outline-text-3" id="text-org8bbb415">
<p>
<a href="https://learnyousomeerlang.com/starting-out">Learn You Some Erlang for Great Good</a>
</p>

<p>
An accessible community resource with excellent, practical sections covering the shell, distribution, and general Erlang philosophy.
</p>

<p>
<a href="https://www.erlang.org/doc/apps/stdlib/shell.html">Erlang shell: official docs</a>
</p>

<p>
<b><b>The Erlang Shell in Depth</b></b>: Detailed reference for the commands available inside the Erlang shell, such as `c(Module)` and job control (`^G`).
</p>
</div>
</div>
<div id="outline-container-orgb670eea" class="outline-3">
<h3 id="orgb670eea"><a href="https://www.erlang.org/docs/24/man/erlang.el">Emacs/LISP Integration Specifics</a></h3>
<div class="outline-text-3" id="text-orgb670eea">
<p>
<b><b>Official Erlang Mode for Emacs</b></b>: The core documentation for `erlang.el`, which provides the foundation for commands like `erlang-shell` and `erlang-compile`.
</p>

<p>
<a href="https://jamesaimonetti.com/posts/2010/01/07/connect-to-remote-erlang-shell-while-inside-emacs/">Blog Post: Connect to remote erlang shell while inside emacs</a>
</p>

<p>
How to connect to a remote shell in emacs (but a little.. different)
</p>

<p>
<a href="https://www.erlang.org/faq/problems">Section 9.8 - Why won't my distributed Erlang nodes communicate?</a>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
